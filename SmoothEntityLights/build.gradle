import groovy.json.*

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true    }
}

plugins {
	id "com.matthewprenger.cursegradle" version "1.4.0"
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'eclipse'

// Define properties file
ext.configFile = file "build.properties"
configFile.withReader {
    // Load config.  It shall from now be referenced as simply config or project.config
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
}

version = "${config.mod_version}.${config.build_number}-MC${config.mc_version}"
group = config.group
archivesBaseName = config.archivesBaseName

sourceCompatibility = targetCompatibility = config.java_version // Need this here so eclipse task generates correctly.
compileJava {
    sourceCompatibility = targetCompatibility = config.java_version
}

dependencies {
	minecraft "net.minecraftforge:forge:${config.mc_version}-${config.forge_version}"
}

task wrapper(type: Wrapper) {
    gradleVersion = config.gradleVersion
}

minecraft {
    mappings channel: 'stable', version: "${config.mappings}-${config.mc_version}"
	accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

	// Default run configurations.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                sel {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                sel {
                    source sourceSets.main
                }
            }
        }
    }		
    
}

processResources {
    //redo task if any of these properties change
    inputs.property "version", "${config.mod_version}.${config.build_number}"
    inputs.property "mc_version", config.mc_version

    // Replace properties in info files
    from(sourceSets.main.resources.srcDirs) {
        include '*.info'
        expand 'version':"${config.mod_version}.${config.build_number}", 'mc_version':config.mc_version
    }

    // Copy everything else
    from(sourceSets.main.resources.srcDirs) {
        exclude '*.info'
        include 'assets/**/*.*'
    }
}

jar {
    manifest {
        attributes([
            "Specification-Title": "Smooth Entity Light",
            "Specification-Vendor": "LakMoore",
            "Specification-Version": "1",
            "Implementation-Title": project.name,
            "Implementation-Version": "${version}",
            "Implementation-Vendor" :"LakMoore",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

curseforge {
	apiKey = project.curseForgeApiKey
	project {
		id = config.curseProjectId
		changelog = file('src/main/resources/changelog.txt')
		releaseType = 'release'
		addGameVersion "${config.mc_version}"

		mainArtifact(jar) {
			displayName = "${config.archivesBaseName}-${config.mod_version}.${config.build_number}-MC${config.mc_version}"
		}		
	}
}

//call curseforge, then update the version file and increment the build number ready for next time
task lakPublish(dependsOn: 'curseforge') {    
	doLast {
	    def updateJsonFile = file(System.getProperty("user.home") + "/Dropbox/MinecraftModFiles/versions/${config.archivesBaseName}.json")
	    if (updateJsonFile.exists()) {
		    def updateJson = new JsonSlurper().parse(updateJsonFile) as Map
			
			// Ensure there is a section for this MC version
			updateJson.get("${config.mc_version}" as String, [:])
		
		    // Add to version section
		    updateJson."${config.mc_version}"."${config.mod_version}.${config.build_number}" = "See changelog.txt"
		
		    // Update promos
		    updateJson.promos."${config.mc_version}-latest" = "${config.mod_version}.${config.build_number}"
		    updateJson.promos."${config.mc_version}-recommended" = "${config.mod_version}.${config.build_number}"
		
		    updateJsonFile.write(JsonOutput.prettyPrint(JsonOutput.toJson(updateJson)))
	    }
	
	    def cmd = "git tag -a v${config.mod_version}.${config.build_number} -m ''"
	    println cmd.execute().text.split().size()
		//def proc = cmd.execute()
		//proc.waitFor()
	    
	    config.build_number = (config.build_number.toString().toInteger()) + 1
	    configFile.withWriter {
	        config.toProperties().store(it, "")
	    }
    }
}

configure(lakPublish) {   
    group = 'upload'
    description = 'upload then update version and build number, ready for next time'
}
